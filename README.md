# Третий семестр: Промышленное программирование, Операционные системы и Алгоритмы и структура данных.
## Лабораторные работы выполненные за первое полугодие второго курса обучения в БГУ:
### ПП(Промышленное программирование):
- [Лабораторная работа 1](#лабораторная-работа-1)
- [Лабораторная работа 1.1: UNIT-тестирование.](#лабораторная-работа-11-unit-тестирование)
- [Лабораторная работа 2: Обработка строк.](#лабораторная-работа-2-обработка-строк)
- [Лабораторная работа 2.1: UNIT-тестирование.](#лабораторная-работа-21-unit-тестирование)
- [Лабораторная работа 3: Проект. Обработка коллекций. XML. JSON. UNIT-тестирование.](#лабораторная-работа-3-проект-обработка-коллекций-xml-json-unit-тестирование)

### Примечание: Во всех лабораторных по ПП выполнен шестой вариант индивидульного задания!

### ОС(Операционные системы):
- [Лабораторная работа 1: Создание процессов.](#лабораторная-работа-1-создание-процессов)
- [Лабораторная работа 2: Создание потоков.](#лабораторная-работа-2-создание-потоков)
- [Лабораторная работа 3: Синхронизация потоков при помощи критических секций и событий. Обработка тупиков.](#лабораторная-работа-3-синхронизация-потоков-при-помощи-критических-секций-и-событий-обработка-тупиков)

### АиСД(Алгоритмы и структура данных):
- [Задача 0.0.0](#задача-000)
- [Задача 0.0.1: Бинарный поиск.](#задача-001-бинарный-поиск)
- [Задача 1.0.1: Путь лягушки.](#задача-101-путь-лягушки)
- [Задача 1.0.2: Единицы (часть 1).](#задача-102-единицы-часть-1)
- [Задача 1.0.3: Единицы (часть 2).](#задача-103-единицы-часть-2)
- [Задача 1.0.4: Порядок перемножения матриц.](#задача-104-порядок-перемножения-матриц)
- [Задача 1.0.5: LCS.](#задача-105-lcs)
- [Задача 1.0.6: Палиндром.](#задача-106-палиндром)
- [Задача 1.58: Свертка строки.](#задача-158-свертка-строки)
- [Задача 2.0.1: Построить дерево.](#задача-201-построить-дерево)
- [Задача 2.0.2: Удалить из дерева.](#задача-202-удалить-из-дерева)
- [Задача 2.0.3: Является ли бинарное дерево поисковым?](#задача-203-является-ли-бинарное-дерево-поисковым)

# ПП(Промышленное программирование)

## Лабораторная работа 1

### Общее задание:
1. Разработать консольное приложение на Java.
2. Вычисление ряда выполнить в отдельном классе (не загрузочном)!
3. Функция представлена в виде своего ряда Тейлора. Вычислить приближенное значение суммы этого бесконечного ряда. Вычисления заканчивать, когда очередное слагаемое окажется по модулю меньше заданного числа ∑. Вид этого числа определяется  следующим условием:
 ∑ = 10-k, где k – натуральное число. 
4. Значения x и k ввести с клавиатуры. 
5. Факториал и степень в слагаемых отдельно не считать!
6. Сравнить полученный результат со значением, вычисленным через стандартные функции.
7. Класс Scaner использовать для варианта с простыми типами 
8. Класс BufferedReader для чтения данных использовать для варианта с большими типами Big...
9. Используя  класс Formatter реализовать :
    - Выводить некоторые целые значения (округлить) в восьмеричном и шестнадцатеричном виде
    - Для чисел с плавающей точкой использовать спецификатор минимальной ширины поля и 
    спецификатор точности (количество знаков после запятой =к+1)
    - Использовать флаги (flags) форматирования: 0,+)#
10. Использовать  для вывода спецификатор минимальной ширины поля и спецификатор точности в методе System.out.println().

### Индивидуальное задание:
![Гиперболический синус](https://github.com/den1s-k0/Semester-3/blob/8a4e383658df96002eafb6968b9b235fed683c9e/IP(Industrial%20Programming)/Lab%20IP%2001-6%20KD/Lab%20IP%2001-6%20KD.png)

## Лабораторная работа 1.1: UNIT-тестирование.

### Общее задание:
1. Использовать UNIT-тесты для тестирования лабораторной 1
2. Запись кода и кода тестов на GitHub

## Лабораторная работа 2: Обработка строк.

### Общее задание:
1. Запрашивает две строки. 
Первая строка содержит лексемы (на которые делит вторая строка),  состоящие из любых символов, которые можно ввести с клавиатуры, например, числа (  см. индивидуальные варианты,  2-й или 8-й или 10-й или 16-й систем счисления). 
Вторая строка содержит символы разделители (1 разделитель - 1 символ, без повторений)
Между лексемами в первой строке может стоять >1 разделителя и разные разделители. 
2. Выполнить обработку строки в отдельном классе (не загрузочном)!
3. StringTokenizer использовать, если между лексемами стоит >1 разделителя и разные разделители) или  String.Split (без регулярного выражения,если только всего один разделитель и по одному разделителю между лексемами или с регулярным выражением.
4. Использовать методы :
    - Для строк String: format, charAt, getChars, Split, Remove, Substring, Replace,  IndexOf, LastIndexOf
    - Для строк StringBuffer\StringBuilder (обязательно): delete, insert, reverse
5. Если в задании есть поиск чисел не из 10с\с - использовать перегруженный метод Integer.parseInt c двумя параметрами.
6. Считать\записать данные\результаты из\в файл. Использовать классы : FileReader, FileWriter, BufferedReader, BufferedWriter.

7. Обработку дат и времени осуществлять при помощи регулярных выражений (количество дней во всех месяцах проверять не нужно).

8. Для валидации дат и времени использовать классы Date, (Calendar),  SimpleDateFormat ( метод setLenient). Для вывода даты и времени использовать классы Format, DateFormat или Formatter.

9. Записать в Arrays, отсортировать список лексем даты\времени или других (согласно инд. варианту) с помощью Соmparator.

- Используя классы NumberFormat, DecimalFormat(Formatter)., вывести проценты и денежные единицы (страну указать в Locale ).

### Индивидуальное задание:
Разбить первую строку на лексемы (используя разделители из  второй строки), определить в ней целые числа 10-й с\с.  Числа записать в новый отдельные массив. Среди лексем не являющихся числами, найти время (ММ\ЧЧ\СС). Добавить в строку случайное число после числа 10-й с\с или в середину строки(если нет) .  Подстроку (с лексемой самой маленькой длины), начинающуюся цифрой - удалить из строки. Все результаты сформировать в строки и вывести.


## Лабораторная работа 2.1: UNIT-тестирование.

### Общее задание:
1. Использовать UNIT-тесты для тестирования лабораторной 1
2. Использовать тип проекта Maven
3. Запись кода и кода тестов на GitHub

## Лабораторная работа 3: Проект. Обработка коллекций. XML. JSON. UNIT-тестирование.

### Общее задание:
1. В  статической функции\методе main только создавать объекты других классов и вызывать некоторые методы этих классов. (создание меню (п. 10) реализовать в отдельной функции.
2. Создать абстрактные классы. 
3. Создать классы для хранения списков объектов, List и Map (наследники абстрактного класса).
4. Создать классы для  чтения\записи данных в\из файл(а) *.txt
5. Создать класс (наследник абстрактного) для хранения полей объекта(согласно индивидуальному проекту), например, автомобиль содержит поля: id, тип, модель, мощность двигателя, максимальная скорость дата выпуска, цена и т.д. Для дат использовать  тип Date. Создать методы Get ,  Set… (автогенерация геттеров и сеттеров), переопределить метод toString() для вывода на консоль\файл объектов.
6. Проверка входных данных (данные, числа и т.д.) на корректность(данные  изначально считать из текстового файла). Например, некорректные элементы обнулять(или делать пустые поля\элементы) ИЛИ не читать весь объект\строку (например, полностью информацию об одном автомобиле). Выводить запись об ошибке и некорректную строку на консоль или в *.log файл.
7. Запись объектов данных в List, Map (можно использовать SortMap для сортировки).
8. Ввод с консоли новых данных для объекта и добавление\обновление\удаление (CUD)  данных в List, Map (и обновление List\Мap и файла txt).
9. Использовать итераторы для вывода.
10. Создание меню (отдельный класс) для выбора действий : добавление,редактирование информации с консоли, чтение\запись данных из\в какой-то формат.
11. Сортировка данных по выбранным полям, используя Сollections, Соmparator (можно использовать SortMap по одному из полей). Лямбда-выражения.
12. Чтение из XML- файла, запись в XML файл (DOM –технология)
13. Чтение из JSON- файла, запись в JSON файл.
14. Шифрование данных.
15. Архивация (jar, zip).
16. Использовать UNIT-тесты для тестирования.
17. Запись на GitHub

### Индивидуальное задание:
Кафе, разработка индивидуального меню.

# ОС(Операционные системы)

## Лабораторная работа 1: Создание процессов.

### Задача:
Написать консольную программу Main и две утилиты (служебные программы)
Creator и Reporter, которые выполняют следующие действия.

### Утилита Creator:
Утилита создает бинарный файл, имя которого и количество записей в котором
получает через командную строку.
Записи файла вводятся с консоли и имеют следующую структуру:  

    struct employee{  
     int num; // идентификационный номер сотрудника  
     char name[10]; // имя сотрудника  
     double hours; // количество отработанных часов  
    };
 
### Утилита Reporter:
Утилита создает текстовый файл, содержащий упорядоченный список сотрудников
с начисленной заработной платой. Отчет формируется на основе бинарного файла, созданного
программой Creator.
1. Утилита получает через командную строку следующие данные:
    - Имя исходного бинарного файла.
    - Имя файла отчета.
    - Оплата за час работы.
2. Отчет содержит следующие строки:
    - Заголовок: Отчет по файлу «имя исходного бинарного файла».
    - Строка: Номер сотрудника, имя сотрудника, часы, зарплата.
    - Список сотрудников по строкам. Каждая строка содержит информацию из
соответствующей записи бинарного файла, а последний столбец строки -
начисленную зарплату = кол-ву отработанных часов * оплату за час работы.

### Программа Main:
Программа выполняет следующие действия:
1. Запрашивает с консоли имя бинарного файла и количество записей в этом файле.
2. Запускает утилиту Creator, которой передает через командную строку имя
создаваемого бинарного файла и количество записей в этом файле.
3. Ждет завершения работы утилиты Creator.
4. Выводит содержимое созданного бинарного файла на консоль.
5. Запрашивает с консоли:
    - Имя файла отчета.
    - Оплату за час работы.
6. Запускает утилиту Reporter, которой передает через командную строку:
    - Имя исходного бинарного файла.
    - Имя файла отчета.
    - Оплату за час работы.
7. Ждет завершения работы утилиты Reporter.
8. Выводит отчет на консоль.
9. Завершает свою работу.
   
### Примечание:
Для ожидания завершения работы процессов Creator и Reporter
использовать функцию:

    DWORD WaitForSingleObject(  
     HANDLE hHandle, // дескриптор объекта  
     DWORD dwMilliseconds // интервал ожидания в миллисекундах  
    );  
 
где второй параметр установить равным INFINITE, например

    WaitForSingleObject(hCreator, INFINITE);
 
здесь hCreator – дескриптор процесса Creator.

## Лабораторная работа 2: Создание потоков.

### Задача:
Написать программу для консольного процесса, который состоит из трех потоков: main,
min_max и average.

### Поток main:
Поток main должен выполнить следующие действия:
1. Создать массив целых чисел, размерность и элементы которого вводятся с консоли.
2. Создать потоки min_max и average.
3. Дождаться завершения потоков min_max и average.
4. Заменить максимальный и минимальный элементы массива на среднее значение элементов
массива. Вывести полученные результаты на консоль.
5. Завершить работу.

### Поток min_max:
Поток min_max должен выполнить следующие действия:
1. Найти минимальный и максимальный элементы массива и вывести их на консоль. После
каждого сравнения элементов «спать» 7 миллисекунд.
2. Завершить свою работу.

### Поток average:
Поток average должен выполнить следующие действия:
1. Найти среднее арифметическое значение элементов массива и вывести его на консоль.
После каждой операции суммирования элементов «спать» 12 миллисекунд.
2. Завершить свою работу.

### Примечания:
1.Для ожидания завершения работы потоков min_max и average использовать функцию:

    DWORD WaitForSingleObject(
     HANDLE hHandle, // дескриптор объекта
     DWORD dwMilliseconds // интервал ожидания в миллисекундах
    );
где второй параметр установить равным INFINITE. Например

    WaitForSingleObject(hAverage, INFINITE); // ждать завершения потока   
Здесь hAverage – дескриптор потока average.  

2.Для засыпания использовать функцию:

    VOID Sleep(
     DWORD dwMilliseconds // миллисекунды
    );
Например,

    Sleep(12); // спать 12 миллисекунд

## Лабораторная работа 3: Синхронизация потоков при помощи критических секций и событий. Обработка тупиков.

### Задача:
Написать программу для консольного процесса, который состоит из потока main и
нескольких экземпляров потока marker.

### Поток main:
Поток main должен выполнять следующие действия:
1. Захватить память под массив целых чисел, размерность которого вводится с консоли.
2. Инициализировать элементы массива нулями.
3. Запросить количество потоков marker, которые требуется запустить.
4. Запустить заданное количество экземпляров потока marker. В качестве параметра
каждому экземпляру потока marker передать его порядковый номер в запуске.
5. Дать сигнал на начало работы всех потоков marker.
6. Выполнять в цикле следующие действия:
    - 6.1. Ждать, пока все потоки marker не подадут сигналы о невозможности
    продолжения своей работы.
    - 6.2. Вывести содержимое массива на консоль.
    - 6.3. Запросить с консоли порядковый номер потока marker, которому будет подан
    сигнал на завершение своей работы.
    - 6.4. Подать потоку marker, номер которого получен в пункте 6.3, сигнал на
    завершение работы.
    - 6.5. Ждать завершение работы потока marker, которому был подан сигнал на
    завершение работы в пункте 6.4.
    - 6.6. Вывести содержимое массива на консоль.
    - 6.7. Подать сигнал на продолжение работы, оставшимся потокам marker.
7. Завершить свою работу после завершения работы всех потоков marker.

### Поток marker:
Поток marker должен выполнять следующие действия:
1. Начать работу по сигналу от потока main.
2. Инициализировать генерацию последовательности случайных чисел. Для этого
использовать функцию srand, которой передать в качестве аргумента свой
порядковый номер.
3. Работать циклически, выполняя на каждом цикле следующие действия:
    - 3.1. Генерировать случайное число, используя функцию rand.
    - 3.2. Разделить это число по модулю на размерность массива.
    - 3.3. Если элемент массива, индекс которого равен результату деления, равен нулю, то
    выполнить следующие действия:
        + 3.3.1. Поспать 5 миллисекунд.
        + 3.3.2. Занести в элемент, индекс которого вычислен, свой порядковый номер.
        + 3.3.3. Поспать 5 миллисекунд.
        + 3.3.4. Продолжить исполнение цикла 3.
    - 3.4. В противном случае:
        + 3.4.1. Вывести на консоль следующую информацию:
            * свой порядковый номер;
            * количество помеченных элементов;
            * индекс элемента массива, который невозможно пометить.
        + 3.4.2. Дать сигнал потоку main на невозможность продолжения своей работы.
        + 3.4.3. Ждать ответный сигнал на продолжение или завершение работы от потока
        main.
4. Если получен сигнал на завершение работы, то выполнить следующие действия:
    - 4.1. Заполнить нулями в массиве все элементы, которые он пометил.
    - 4.2. Завершить работу.
5. Если получен сигнал на продолжение работы, то продолжить исполнение цикла из
пункта 3.

# АиСД(Алгоритмы и структура данных)

## Задача 0.0.0

### Ограничения:
- Имя входного файла: input.txt
- Имя выходного файла: output.txt
- Ограничение по времени: 1 с
- Ограничение по памяти: нет

### Условие:
Дано бинарное поисковое дерево, в котором ключи вершин являются целыми числами в диапазоне от $-2^{31}$ до $2^{31} - 1$ включительно. Найдите сумму ключей всех вершин дерева.

### Формат входных данных:
Входной файл содержит последовательность чисел — ключи вершин в порядке добавления в дерево. Ключи задаются в формате по одному в строке.
В поисковом дереве все ключи по определению уникальны, поэтому при попытке добавить в дерево ключ, который там уже есть, он игнорируется.

### Формат выходных данных:
Выведите единственное число — сумму ключей в построенном дереве.

## Задача 0.0.1: Бинарный поиск.

### Ограничения:
- Имя входного файла: стандартный ввод
- Имя выходного файла: стандартный вывод
- Ограничение по времени: 3 с
- Ограничение по памяти: 256 МБ

### Условие:
Реализуйте бинарный поиск на массиве чисел, отсортированном в неубывающем порядке.Запрещается использование готовых функций бинарного поиска из стандартных библиотек.

### Формат входных данных:
В первой строке записано целое число $n$ — количество чисел в массиве ($0 \leqslant n \leqslant 3 \cdot 10^5$).Во второй строке через пробел записаны $n$ чисел массива. Все числа целые и принадлежат промежутку от $-2^{31}$ до $2^{31} - 1$ включительно. Числа в массиве упорядочены по неубыванию.В третьей строке записано целое число $k$ — количество запросов ($0 \leqslant k \leqslant 3 \cdot 10^5$).В четвёртой строке через пробел записаны $k$ целых чисел-запросов из промежутка от $-2^{31}$ до $2^{31} - 1$ включительно.

### Формат выходных данных:
Для каждого числа-запроса $x$ в отдельной строке выведите через пробел числа $b$, $l$ и $r$, где $b$ равно $1$, если $x$ присутствует в массиве, или $0$ в противном случае; $l$ — индекс первого элемента, большего либо равного $x$; $r$ — индекс первого элемента, большего $x$. Элементы массива нумеруются индексами от $0$ до $n-1$. Если подходящих элементов в массиве нет, договоримся, что возвращаемый индекс будет равен $n$.

## Задача 1.0.1: Путь лягушки.
- Имя входного файла: стандартный ввод
- Имя выходного файла: стандартный вывод
- Ограничение по времени: 1 с
- Ограничение по памяти: 256 МБ

### Условие:
В одном очень длинном и узком пруду по кувшинкам прыгает лягушка. Кувшинки в пруду расположены в один ряд. Лягушка начинает прыгать с первой кувшинки ряда и хочет закончить на последней. Но в силу вредности характера лягушка согласна прыгать только вперед через одну или через две кувшинки. Например, с кувшинки номер 1 она может прыгнуть лишь на кувшинки номер 3 и номер 4.

На некоторых кувшинках сидят комарики. А именно, на i-й кувшинке сидят ai комаров. Когда лягушка приземляется на кувшинку, она съедает всех комариков, сидящих на ней. Лягушка хочет спланировать свой маршрут так, чтобы съесть как можно больше комаров. Помогите ей: скажите, какие кувшинки она должна посетить на своем пути.

### Формат входных данных:
Первая строка входа содержит n — число кувшинок в пруду (1 ≤ n ≤ 100 000). Вторая строка содержит n чисел, разделенных одиночными пробелами. i-е число сообщает, сколько комаров сидит на i-й кувшинке (1 ≤ i ≤ n). Все числа целые, неотрицательные и не превосходят 1000.

### Формат выходных данных:
В первой строке выведите одно число — максимальное число комаров, которые может съесть лягушка. Во второй строке выведите последовательность чисел — номера тех кувшинок, на которых должна побывать лягушка, в возрастающем порядке. Если решений несколько, выведите любое.
Если лягушка не может добраться до последней кувшинки, то выведите одно число −1.

## Задача 1.0.2: Единицы (часть 1).
- Имя входного файла: стандартный ввод
- Имя выходного файла: стандартный вывод
- Ограничение по времени: 1 с
- Ограничение по памяти: 256 МБ

### Условие:
Дано число $N$. Необходимо определить, сколько есть бинарных строк длины $N$, в которых ровно $K$ единиц.

### Формат входных данных:
Первая строка входных данных содержит два целых неотрицательных числа $N$ и $K$ $(0 \le K \le N \le 1000)$.

### Формат выходных данных:
Выведите одно число - ответ на задачу. Так как ответ может быть очень большим, необходимо его вывести по модулю $10^9 + 7$.

## Задача 1.0.3: Единицы (часть 2).
- Имя входного файла: стандартный ввод
- Имя выходного файла: стандартный вывод
- Ограничение по времени: 1 с
- Ограничение по памяти: 256 МБ

### Условие:
Дано число $N$. Необходимо определить, сколько есть бинарных строк длины $N$, в которых ровно $K$ единиц.

### Формат входных данных:
Первая строка входных данных содержит два целых неотрицательных числа $N$ и $K$ $(0 \le K \le N \le 10^6)$.

### Формат выходных данных:
Выведите одно число - ответ на задачу. Так как ответ может быть очень большим, необходимо его вывести по модулю $10^9 + 7$.

## Задача 1.0.4: Порядок перемножения матриц.
- Имя входного файла: input.txt
- Имя выходного файла: output.txt
- Ограничение по времени: 1 с
- Ограничение по памяти: 256 МБ

### Условие:
Дана последовательность из s матриц A1, A2, …, As. Требуется определить, в каком порядке их следует перемножать, чтобы число атомарных операций умножения было минимальным. Матрицы предполагаются совместимыми по отношению к матричному умножению (т. е. число столбцов матрицы Ai − 1 совпадает с числом строк матрицы Ai).

Будем считать, что произведение матриц — операция, которая принимает на вход две матрицы размера k × m и m × n и возвращает матрицу размера k × n, затратив на это kmn атомарных операций умножения. (Базовый тип позволяет хранить любой элемент итоговой и любой возможной промежуточной матрицы, поэтому умножение двух элементов требует одной атомарной операции.)

Так как перемножение матриц ассоциативно, итоговая матрица не зависит от порядка выполнения операций умножения. Другими словами, нет разницы, в каком порядке расставляются скобки между множителями, результат будет один и тот же.

### Формат входных данных:
В первой строке задано число s матриц (2 ≤ s ≤ 100). В последующих s строках заданы размеры матриц: строка i + 1 содержит через пробел число ni строк и число mi столбцов матрицы Ai (1 ≤ ni, mi ≤ 100). Гарантируется, что mi совпадает с ni + 1 для всех индексов i от 1 до s − 1.

### Формат выходных данных:
Выведите минимальное число атомарных операций умножения, необходимое для перемножения s матриц.

## Задача 1.0.5: LCS.
- Имя входного файла: стандартный ввод
- Имя выходного файла: стандартный вывод
- Ограничение по времени: 2 с
- Ограничение по памяти: 64 МБ

### Условие:
Даны две последовательности $A$ и $B$, каждая имеет длину $n$.Найти наибольшее $k$, для которого существуют две последовательности индексов $0 \le i_1 < i_2 < \ldots < i_k < n$ и $0 \le j_1 < j_2 < \ldots < j_k < n$, что $A_{i_1} = B_{j_1}$, $A_{i_2} = B_{j_2}$, …, $A_{i_k} = B_{j_k}$. Также нужно найти и сами последовательности индексов.

### Формат входных данных:
В первой строке записано число $n$ ($1 \le n \le 1000$), длина последовательностей $A$ и $B$. Во второй строке содержится $n$ целых чисел $a_i$ ($1 \le a_i \le 1000$) — элементы последовательности $A$. В третьей строке содержатся $n$ целых чисел $b_j$ ($1 \le b_j \le 1000$) — элементы последовательности $B$.

### Формат выходных данных:
В первой строке выведите число $k$. Во второй строке выведите индексы $i_{1}\, i_{2}\, \ldots\, i_k$. В третьей строке выведите индексы $j_{1}\, j_{2}\, \ldots\, j_k$. Если подходящий последовательностей индексов несколько, выведите любые из них.

## Задача 1.0.6: Палиндром.
- Имя входного файла: input.txt
- Имя выходного файла: output.txt
- Ограничение по времени: 1 с
- Ограничение по памяти: нет

### Условие:
Вводится непустая строка S, которая имеет длину не более 7000 символов и состоит только из строчных латинских букв. Необходимо удалить из строки минимальное число символов так, чтобы получился палиндром (строка символов, которая читается слева направо и справа налево одинаково).

### Формат входных данных:
В первой строке записана исходная строка S.

### Формат выходных данных:
Выведите в первой строке длину получившегося палиндрома, а во второй строке сам палиндром (если палиндромов несколько, то выведите только один из них).

## Задача 1.58: Свертка строки.
- Имя входного файла: folding.in
- Имя выходного файла: folding.out
- Ограничение по времени: 1 с
- Ограничение по памяти: нет

### Условие:
Билл пытается компактно представить последовательность заглавных букв алфавита от A до Z, сворачивая повторяющиеся подпоследовательности внутри неё. Например, одним из способов представить последовательность AAAAAAAAAABABABCCD является 10(A)2(BA)B2(C)D. Он формально определяет свёрнутую последовательность и операцию разворачивания следующим образом:

- Последовательность, содержащая единственный символ от A до Z, считается сжатой последовательностью. Разворачивание этой последовательности даёт тот же единственный символ.
- Если S и Q — свёрнутые последовательности, то SQ также свёрнутая последовательность. Если S разворачивается в S’, а Q разворачивается в Q’, то SQ разворачивается в S’Q’.
- Если S — свёрнутая последовательность, то X(S) также свёрнутая последовательность, где X — десятичное представление целого числа, большего 1. Если S разворачивается в S’, то X(S) разворачивается в S’, повторяющуюся X раз.

Исходя из этого определения, легко развернуть данную свёрнутую последовательность. Однако Билл гораздо более заинтересован в обратном преобразовании. Он хочет свернуть данную последовательность таким образом, чтобы результирующая свёрнутая последовательность содержала наименьшее возможное число символов.

### Формат входных данных:
На вход подаётся единственная строка длины от 1 до 700, состоящая из символов от A до Z.

### Формат выходных данных:
Выведите кратчайшую возможную свёрнутую последовательность, которая разворачивается в последовательность, данную во входном файле. Если таких последовательностей несколько, выведите любую из них.

## Задача 2.0.1: Построить дерево.
- Имя входного файла: input.txt
- Имя выходного файла: output.txt
- Ограничение по времени: 1 с
- Ограничение по памяти: 256 МБ

### Условие:
По набору ключей постройте бинарное поисковое дерево и выполните его прямой левый обход.

### Формат входных данных:
Входной файл содержит последовательность чисел — ключи вершин в порядке добавления в дерево. Ключи задаются в формате по одному в строке.
В поисковом дереве все ключи по определению уникальны, поэтому при попытке добавить в дерево ключ, который там уже есть, он игнорируется.

### Формат выходных данных:
Выходной файл должен содержать последовательность ключей вершин, полученную прямым левым обходом дерева.

## Задача 2.0.2: Удалить из дерева.
- Имя входного файла: input.txt
- Имя выходного файла: output.txt
- Ограничение по времени: 1 с
- Ограничение по памяти: 256 МБ

### Условие:
По набору ключей постройте бинарное поисковое дерево. Удалите из него ключ (правым удалением), если он есть в дереве. Выполните прямой левый обход полученного дерева.

### Формат входных данных:
В первой строке записано целое число — ключ, который нужно удалить из дерева.  
Вторая строка пустая.

Последующие строки содержат последовательность чисел — ключи вершин в порядке добавления в дерево. Ключи задаются в формате по одному в строке. Дерево содержит хотя бы две вершины.

Напомним, что в поисковом дереве все ключи по определению уникальны, поэтому при попытке добавить в дерево ключ, который там уже есть, он игнорируется.

### Формат выходных данных:
Выведите последовательность ключей вершин, полученную прямым левым обходом дерева.

## Задача 2.0.3: Является ли бинарное дерево поисковым?
- Имя входного файла: bst.in
- Имя выходного файла: bst.out
- Ограничение по времени: 1 с
- Ограничение по памяти: 64 МБ

### Условие:
Задано бинарное дерево. Необходимо проверить, является ли оно поисковым. Будем предполагать, что в бинарном поисковом дереве могут быть вершины с одинаковыми ключами. Тогда, для того, чтобы дерево было поисковым, должно выполняться следующее требование: для каждой вершины $x$ все ключи в левом поддереве вершины $x$ меньше ключа вершины $x$, а все ключи в правом поддереве больше либо равны ключу вершины $x$.

### Формат входных данных:
Первая строка входного файла содержит единственное целое число $n$ ($1 \leq n \leq 8 \cdot 10^5$) – количество вершин в дереве.Следующая строка содержит одно целое число $m$ ($-2^{31} \leq m \leq 2^{31} - 1$) – значение в корневой вершине дерева.В каждой из последующих $n - 1$ строк через пробелы перечисляются три параметра $m$, $p$ и $c$, которые задают какую-либо вершину дерева. $m$ – целое число ($-2^{31} \leq m \leq 2^{31} - 1$), значение, записанное в вершине. $p$ – целое число ($1 \leq p \leq n - 1$), номер строки входного файла, в которой был задан родитель текущей вершины (нумерация строк с нуля). Гарантируется, что $p$ меньше, чем номер текущей строки. $c$ может принимать одно из двух значений `L` или `R`. Значение `L` указывает на то, что текущая вершина присоединена к родительской слева, `R` – справа. Гарантируется, что совокупность всех строк задает корректное бинарное дерево.

### Формат выходных данных:
В единственной строке выведите `YES`, если заданное дерево является бинарным деревом поиска, и `NO` в противном случае.
